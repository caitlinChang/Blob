### git 内部原理
git 是一个内容寻址系统，什么意思呢，就是说git里的数据都是通过键值对的形式存储呢，值就是数据内容，键就是SHA-1哈希值；
Git 中的所有内容，均以树对象和数据对象的形式存储，树对象对应的就是目录，数据对象对应的就是文件。
git/objects 目录下存储着所有数据；
git 中的两种对象：
数据对象: blob
树对象: tree



#### git hash-object
```
git hash-object -w 'test content'
```

读取内容
```
git cat-file -p master^^{tree}
```

#### 树对象
git内部通过树对象的方式存储多文件组织起来的目录信息，包括存储文件名
一个树对象包含了一条或者多条树对象记录，每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针，以及相应的模式、


#### 提交对象

#### 对象存储
```
blob ${content.length}\0
content
``` 
再进行SHA-1校验和

#### Git 分支
> 一个指向某一系列提交之收尾的指针或引用；

所以说 `git checkout branch_name`,是切换到另一个指针上，或者新建一个指针，这个指针指向当前提交对象；
.git/refs/heads 中 相当于把所有的引用存起来，
##### HEAD 引用
当我们执行分支类的操作时，git 会更新 .git/refs/heads 下的文件；
HEAD文件通常是一个符号引用，指向其他引用的一个指针；

但是在某些特殊情况下，HEAD文件可能会包含一个git对象的SHA-1值，这就是游离分支，比如merge出现冲突的时候，就会出现一个游离分支，这个分支让你解决完冲突然后再回到原分支；

当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所执行的 SHA-1值设置其父提交字段；
也就是执行下面这个命令
```
echo 'commit message' | git commit-tree -p ${HEAD文件中记录的SHA-1值}
```

##### tag 引用
> tag，一个固定的引用

通俗来讲，就是给一个commit起一个更简洁的名字；

Git中三种最主要的对象类型，分别是数据对象、树对象、提交对象，其实还有第四种对象，标签对象；
标签对象非常类似于一个提交对象，它于提交对象唯一的区别在于，标签对象通常指向一个提交对象，而不是一个树对象，它像是一个永不移动的分支引用，即永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了；


##### 远程引用
在每一次对远程版本库执行 推送操作时，git会记录下最近一次推送操作时每一个分支所对应的值，并保存在refs/remotes目录下。

远程引用和分支之间最主要的区别在于，远程引用时只读的，虽然可以git checkout 到某个远程引用，但是Git并不会将HEAD引用指向该远程引用；

#### 包文件
```
git gc
```
包文件包含了刚才从文件系统中移除的所有对象的内容，info文件中包含了pack文件的偏移信息，通过info文件可以快速定位任意一个指定对象；

git是怎么打包包文件的
git打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。

#### 引用规范

##### 添加远程仓库
```
git remote add origin url
```
默认情况下，引用规范由`git remote add origin` 命令自动生成，Git获取服务器中的 refs/heads下面的所有引用，并将它写入到本地的refs/remotes/origin/中;


#### 传输协议






#### 维护与数据恢复

##### 数据恢复
在你工作时，Git 会默默记录每次你改变HEAD时它的值；每一次 git commit 或者git checkout 或者 git reset，都会被记录在引用日志中;

